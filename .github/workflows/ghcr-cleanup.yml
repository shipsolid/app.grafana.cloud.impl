name: GHCR Cleanup (Preview & Delete)

on:
  workflow_dispatch:
    inputs:
      scope:
        description: "Target scope"
        type: choice
        options: [user, org]
        default: user
        required: true
      owner:
        description: "User or Org login (e.g., your GitHub username or org name)"
        type: string
        # required: true
        default: shipsolid
      package_filter:
        description: "Substring to match package names (leave blank for all)"
        type: string
        required: false
        default: ""
      keep_latest:
        description: "Keep N latest versions per package (0 = delete all versions)"
        type: number
        default: 0
        required: true
      older_than_days:
        description: "Only delete versions older than N days (0 = ignore age)"
        type: number
        default: 0
        required: true
      dry_run:
        description: "List only; do not delete"
        type: boolean
        default: true
        required: true
      confirm_delete:
        description: "Type EXACTLY: YES-DELETE to enable deletion"
        type: string
        required: false
        default: ""
  push:
    paths:
      - '.github/workflows/ghcr-cleanup.yml'

permissions:
  contents: read

jobs:
  preview:
    name: Preview candidates
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GHCR_TOKEN }}
      SCOPE: ${{ inputs.scope }}
      OWNER: ${{ inputs.owner }}
      PKG_FILTER: ${{ inputs.package_filter }}
      KEEP_LATEST: ${{ inputs.keep_latest }}
      OLDER_THAN_DAYS: ${{ inputs.older_than_days }}
    steps:
      - name: Verify gh and jq present
        run: |
          gh --version
          jq --version
      - name: Detect owner endpoint
        id: detect
        run: |
          set -euo pipefail
          OWNER="${{ inputs.owner }}"
          SCOPE="${{ inputs.scope }}" # 'user' or 'org'

          if [ "${SCOPE}" = "org" ]; then
            ENDPOINT_BASE="/orgs/${OWNER}/packages/container"
            LIST_PATH="/orgs/${OWNER}/packages?package_type=container"
          else
            # Try /users/<OWNER> first; if 404, fall back to /user
            if gh api "/users/${OWNER}/packages?package_type=container" >/dev/null 2>&1; then
              ENDPOINT_BASE="/users/${OWNER}/packages/container"
              LIST_PATH="/users/${OWNER}/packages?package_type=container"
            else
              ENDPOINT_BASE="/user/packages/container"
              LIST_PATH="/user/packages?package_type=container"
            fi
          fi

          echo "endpoint_base=${ENDPOINT_BASE}" >> "$GITHUB_OUTPUT"
          echo "list_path=${LIST_PATH}" >> "$GITHUB_OUTPUT"

      - name: List packages (debug)
        run: |
          gh api "${{ steps.detect.outputs.list_path }}" --jq '.[].name' || {
            echo "Failed to list packages. Check PAT scopes (read:packages) and SSO enablement."; exit 1; }

      - name: List container packages
        id: list
        env:
          GH_TOKEN: ${{ secrets.GHCR_TOKEN }}          # PAT (read:packages required)
          OWNER: ${{ inputs.owner }}                   # optional
          SCOPE: ${{ inputs.scope }}                   # optional: user|org
          PKG_FILTER: ${{ inputs.package_filter }}     # optional substring
        run: |
          chmod +x .github/scripts/list_container_packages.sh
          bash .github/scripts/list_container_packages.sh

      - name: Build preview (versions that WOULD be deleted)
        if: steps.list.outputs.packages != ''
        env:
          GH_TOKEN: ${{ secrets.GHCR_TOKEN }}
          SCOPE: ${{ inputs.scope }}
          OWNER: ${{ inputs.owner }}
          PKG_FILTER: ${{ inputs.package_filter }}
          KEEP_LATEST: ${{ inputs.keep_latest }}
          OLDER_THAN_DAYS: ${{ inputs.older_than_days }}
          PKG_BASE: ${{ env.PKG_BASE }}           # set by the list step via GITHUB_ENV
          # PACKAGES: ${{ steps.list.outputs.packages }}  # optional fallback if you don't rely on packages.txt
        run: |
          chmod +x .github/scripts/build_preview.sh
          .github/scripts/build_preview.sh

      - name: Upload preview artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ghcr-cleanup-preview
          path: PREVIEW.md

      - name: Add preview to job summary
        if: always()
        run: |
          echo "### GHCR Cleanup Preview" >> "$GITHUB_STEP_SUMMARY"
          if [ -f PREVIEW.md ]; then
            cat PREVIEW.md >> "$GITHUB_STEP_SUMMARY"
          else
            echo "_No preview generated._" >> "$GITHUB_STEP_SUMMARY"

  delete:
    name: Delete (requires confirm & not dry-run)
    needs: preview
    if: ${{ inputs.dry_run == false && inputs.confirm_delete == 'YES-DELETE' }}
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GHCR_TOKEN }}
      SCOPE: ${{ inputs.scope }}
      OWNER: ${{ inputs.owner }}
      PKG_FILTER: ${{ inputs.package_filter }}
      KEEP_LATEST: ${{ inputs.keep_latest }}
      OLDER_THAN_DAYS: ${{ inputs.older_than_days }}
    steps:
      - name: Verify gh and jq present
        run: |
          gh --version
          jq --version

      - name: Resolve package base and list
        id: list
        run: |
          set -euo pipefail

          if [ "${SCOPE}" = "org" ]; then
            PKG_LIST_CMD=(gh api -H "Accept: application/vnd.github+json" --paginate "/orgs/${OWNER}/packages?package_type=container")
            PKG_BASE="/orgs/${OWNER}/packages/container"
          else
            PKG_LIST_CMD=(gh api -H "Accept: application/vnd.github+json" --paginate "/users/${OWNER}/packages?package_type=container")
            PKG_BASE="/users/${OWNER}/packages/container"
          fi

          mapfile -t PACKAGES < <("${PKG_LIST_CMD[@]}" --jq '.[].name' | sort -u)
          if [ -n "${PKG_FILTER}" ]; then
            mapfile -t PACKAGES < <(printf "%s\n" "${PACKAGES[@]}" | grep -i "${PKG_FILTER}" || true)
          fi

          if [ "${#PACKAGES[@]}" -eq 0 ]; then
            echo "No matching packages to delete."
            exit 0
          fi

          printf "%s\n" "${PACKAGES[@]}" | tee packages.txt
          echo "PKG_BASE=${PKG_BASE}" >> "$GITHUB_ENV"

      - name: Delete versions per rules
        run: |
          set -euo pipefail

          kept="${KEEP_LATEST}"
          age_days="${OLDER_THAN_DAYS}"

          while IFS= read -r pkg; do
            echo "::group::Deleting from package ${pkg}"

            versions_json="$(gh api -H "Accept: application/vnd.github+json" --paginate "${PKG_BASE}/${pkg}/versions?per_page=100")"

            # Sort newest->oldest
            versions_sorted="$(echo "${versions_json}" | jq -r '
              sort_by(.created_at) | reverse |
              map({
                id: .id,
                created_at: .created_at,
                tags: (.metadata.container.tags // [])
              })
            ')"

            total=$(echo "${versions_sorted}" | jq 'length')

            # Compute candidate list (skip first N by position; optionally filter by age)
            to_delete="$(echo "${versions_sorted}" | jq --argjson keep ${kept} --argjson age_days ${age_days} -r '
              def too_old($d):
                if $d == 0 then true
                else
                  now as $N | .created_at as $C |
                  ( ( ( ( $N | fromdateiso8601 ) - ( $C | fromdateiso8601 ) ) / 86400 ) | floor ) >= $d
                end;

              to_entries
              | map(select(.key >= $keep))
              | map(select( ( $age_days == 0 ) or ( .value | too_old($age_days) ) ))
              | map(.value)
            ')"

            del_count=$(echo "${to_delete}" | jq 'length')
            echo "Total versions: ${total}, deleting: ${del_count}"

            if [ "${del_count}" -gt 0 ]; then
              echo "${to_delete}" | jq -r '.[].id' | while read -r vid; do
                echo "DELETE version id=${vid}"
                gh api -H "Accept: application/vnd.github+json" \
                  --method DELETE "${PKG_BASE}/${pkg}/versions/${vid}" || {
                    echo "WARN: Failed to delete version id=${vid} (continuing)"; }
              done
            fi

            # If keep_latest == 0 and older_than_days == 0, that means delete ALL versions.
            # After all versions are deleted, also delete the empty package (optional but cleaner).
            if [ "${kept}" -eq 0 ] && [ "${age_days}" -eq 0 ]; then
              echo "All versions removed; deleting empty package ${pkg}..."
              gh api -H "Accept: application/vnd.github+json" \
                --method DELETE "${PKG_BASE}/${pkg}" || {
                  echo "WARN: Failed to delete package ${pkg} (might still have versions or be locked)"; }
            fi

            echo "::endgroup::"
          done < packages.txt
