name: GHCR Cleanup (Preview & Delete)

on:
  workflow_dispatch:
    inputs:
      scope:
        description: "Target scope"
        type: choice
        options: [user, org]
        default: user
        required: true
      owner:
        description: "User or Org login (e.g., your GitHub username or org name)"
        type: string
        # required: true
        default: shipsolid
      package_filter:
        description: "Substring to match package names (leave blank for all)"
        type: string
        required: false
        default: ""
      keep_latest:
        description: "Keep N latest versions per package (0 = delete all versions)"
        type: number
        default: 0
        required: true
      older_than_days:
        description: "Only delete versions older than N days (0 = ignore age)"
        type: number
        default: 0
        required: true
      dry_run:
        description: "List only; do not delete"
        type: boolean
        default: true
        required: true
      confirm_delete:
        description: "Type EXACTLY: YES-DELETE to enable deletion"
        type: string
        required: false
        default: ""
  push:
    paths:
      - '.github/workflows/ghcr-cleanup.yml'
      - '.github/scripts/list_container_packages.sh'
      - '.github/scripts/build_preview.sh'

permissions:
  contents: read

jobs:
  preview:
    name: Preview candidates
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GHCR_TOKEN }}
      SCOPE: ${{ inputs.scope }}
      OWNER: ${{ inputs.owner }}
      PKG_FILTER: ${{ inputs.package_filter }}
      KEEP_LATEST: ${{ inputs.keep_latest }}
      OLDER_THAN_DAYS: ${{ inputs.older_than_days }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify gh and jq present
        run: |
          gh --version
          jq --version
      - name: Detect owner endpoint
        id: detect
        run: |
          set -euo pipefail
          OWNER="${{ inputs.owner }}"
          SCOPE="${{ inputs.scope }}" # 'user' or 'org'

          if [ "${SCOPE}" = "org" ]; then
            ENDPOINT_BASE="/orgs/${OWNER}/packages/container"
            LIST_PATH="/orgs/${OWNER}/packages?package_type=container"
          else
            # Try /users/<OWNER> first; if 404, fall back to /user
            if gh api "/users/${OWNER}/packages?package_type=container" >/dev/null 2>&1; then
              ENDPOINT_BASE="/users/${OWNER}/packages/container"
              LIST_PATH="/users/${OWNER}/packages?package_type=container"
            else
              ENDPOINT_BASE="/user/packages/container"
              LIST_PATH="/user/packages?package_type=container"
            fi
          fi

          echo "endpoint_base=${ENDPOINT_BASE}" >> "$GITHUB_OUTPUT"
          echo "list_path=${LIST_PATH}" >> "$GITHUB_OUTPUT"

      - name: List packages (debug)
        run: |
          gh api "${{ steps.detect.outputs.list_path }}" --jq '.[].name' || {
            echo "Failed to list packages. Check PAT scopes (read:packages) and SSO enablement."; exit 1; }

      - name: List container packages
        id: list
        env:
          GH_TOKEN: ${{ secrets.GHCR_TOKEN }}          # PAT (read:packages required)
          OWNER: ${{ inputs.owner }}                   # optional
          SCOPE: ${{ inputs.scope }}                   # optional: user|org
          PKG_FILTER: ${{ inputs.package_filter }}     # optional substring
        run: |
          chmod +x .github/scripts/list_container_packages.sh
          bash .github/scripts/list_container_packages.sh

      - name: Build preview (versions that WOULD be deleted)
        if: steps.list.outputs.packages != ''
        env:
          GH_TOKEN: ${{ secrets.GHCR_TOKEN }}
          SCOPE: ${{ inputs.scope }}
          OWNER: ${{ inputs.owner }}
          PKG_FILTER: ${{ inputs.package_filter }}
          KEEP_LATEST: ${{ inputs.keep_latest }}
          OLDER_THAN_DAYS: ${{ inputs.older_than_days }}
          PKG_BASE: ${{ env.PKG_BASE }}           # set by the list step via GITHUB_ENV
          # PACKAGES: ${{ steps.list.outputs.packages }}  # optional fallback if you don't rely on packages.txt
        run: |
          chmod +x .github/scripts/build_preview.sh
          .github/scripts/build_preview.sh

      - name: Upload preview artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ghcr-cleanup-preview
          path: PREVIEW.md

      - name: Add preview to job summary
        if: always()
        run: |
          echo "### GHCR Cleanup Preview" >> "$GITHUB_STEP_SUMMARY"
          if [ -f PREVIEW.md ]; then
            cat PREVIEW.md >> "$GITHUB_STEP_SUMMARY"
          else
            echo "_No preview generated._" >> "$GITHUB_STEP_SUMMARY"
          fi

  delete:
    name: Delete (requires confirm & not dry-run)
    needs: preview
    if: ${{ inputs.dry_run == false && inputs.confirm_delete == 'YES-DELETE' }}
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GHCR_TOKEN }}
      SCOPE: ${{ inputs.scope }}
      OWNER: ${{ inputs.owner }}
      PKG_FILTER: ${{ inputs.package_filter }}
      KEEP_LATEST: ${{ inputs.keep_latest }}
      OLDER_THAN_DAYS: ${{ inputs.older_than_days }}
    steps:
      - name: Verify gh and jq present
        run: |
          gh --version
          jq --version

      - name: Resolve package base and list
        id: list
        env:
          GH_TOKEN: ${{ secrets.GHCR_TOKEN }}
        run: |
          set -euo pipefail

          # Build list command
          if [ "${SCOPE}" = "org" ]; then
            PKG_LIST_CMD=(gh api -H "Accept: application/vnd.github+json" --paginate "/orgs/${OWNER}/packages?package_type=container")
            PKG_BASE="/orgs/${OWNER}/packages/container"
          else
            PKG_LIST_CMD=(gh api -H "Accept: application/vnd.github+json" --paginate "/users/${OWNER}/packages?package_type=container")
            PKG_BASE="/users/${OWNER}/packages/container"
          fi

          # Collect package names (unique)
          mapfile -t PACKAGES < <("${PKG_LIST_CMD[@]}" --jq '.[].name' | sort -u)

          # Optional filter (safe under set -u)
          if [ -n "${PKG_FILTER:-}" ]; then
            mapfile -t PACKAGES < <(printf "%s\n" "${PACKAGES[@]}" | grep -i -- "${PKG_FILTER}" || true)
          fi

          if [ "${#PACKAGES[@]}" -eq 0 ]; then
            echo "No matching packages to delete."
            # Export empty packages so downstream step can short-circuit
            echo "packages=" >> "$GITHUB_OUTPUT"
            echo "PKG_BASE=${PKG_BASE}" >> "$GITHUB_ENV"
            exit 0
          fi

          printf "%s\n" "${PACKAGES[@]}" | tee packages.txt
          {
            echo "packages<<EOF"
            printf "%s\n" "${PACKAGES[@]}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          # Validate PKG_BASE once using first package; fall back to /user if needed
          urlenc() { jq -rn --arg v "$1" '$v|@uri'; }
          first="${PACKAGES[0]}"
          first_enc="$(urlenc "$first")"

          if ! gh api -H "Accept: application/vnd.github+json" "${PKG_BASE}/${first_enc}/versions?per_page=1" >/dev/null 2>&1; then
            # Try alternate base paths
            cand_bases=(
              "/users/${OWNER}/packages/container"
              "/user/packages/container"
              "/orgs/${OWNER}/packages/container"
            )
            for b in "${cand_bases[@]}"; do
              if gh api -H "Accept: application/vnd.github+json" "${b}/${first_enc}/versions?per_page=1" >/dev/null 2>&1; then
                PKG_BASE="$b"
                break
              fi
            done
          fi

          echo "PKG_BASE=${PKG_BASE}" >> "$GITHUB_ENV"

      - name: Delete versions per rules
        if: steps.list.outputs.packages != ''
        env:
          GH_TOKEN: ${{ secrets.GHCR_TOKEN }}
        run: |
          set -euo pipefail

          kept="${KEEP_LATEST}"
          age_days="${OLDER_THAN_DAYS}"

          urlenc() { jq -rn --arg v "$1" '$v|@uri'; }

          # Small retry helper for transient 429/5xx
          api_delete() {
            local path="$1"
            local attempt=0
            local max=5
            local delay=1
            while :; do
              if gh api -H "Accept: application/vnd.github+json" --method DELETE "$path"; then
                return 0
              fi
              code=$?
              attempt=$((attempt+1))
              if [ $attempt -ge $max ]; then
                return $code
              fi
              sleep $delay
              delay=$((delay*2))
            done
          }

          while IFS= read -r pkg; do
            [ -z "$pkg" ] && continue
            echo "::group::Deleting from package ${pkg}"

            pkg_enc="$(urlenc "$pkg")"

            # Get versions (newest->oldest)
            versions_json="$(gh api -H "Accept: application/vnd.github+json" --paginate "${PKG_BASE}/${pkg_enc}/versions?per_page=100")" || {
              # If this 404s, try re-detecting PKG_BASE for this package
              cand_bases=(
                "/users/${OWNER}/packages/container"
                "/user/packages/container"
                "/orgs/${OWNER}/packages/container"
              )
              for b in "${cand_bases[@]}"; do
                if gh api -H "Accept: application/vnd.github+json" "${b}/${pkg_enc}/versions?per_page=1" >/dev/null 2>&1; then
                  PKG_BASE="$b"
                  break
                fi
              done
              versions_json="$(gh api -H "Accept: application/vnd.github+json" --paginate "${PKG_BASE}/${pkg_enc}/versions?per_page=100")"
            }

            versions_sorted="$(echo "${versions_json}" | jq -r '
              sort_by(.created_at) | reverse |
              map({ id: .id, created_at: .created_at, tags: (.metadata.container.tags // []) })
            ')"

            total=$(echo "${versions_sorted}" | jq 'length')

            to_delete="$(echo "${versions_sorted}" | jq --argjson keep ${kept} --argjson age_days ${age_days} -r '
              def too_old($d):
                if $d == 0 then true
                else ((now - (.created_at | fromdateiso8601)) / 86400 | floor) >= $d
                end;
              to_entries
              | map(select(.key >= $keep))
              | map(select( ($age_days == 0) or ( .value | too_old($age_days) ) ))
              | map(.value)
            ')"

            del_count=$(echo "${to_delete}" | jq 'length')
            echo "Total versions: ${total}, deleting: ${del_count}"

            if [ "${del_count}" -gt 0 ]; then
              echo "${to_delete}" | jq -r '.[].id' | while read -r vid; do
                echo "DELETE version id=${vid}"
                if ! api_delete "${PKG_BASE}/${pkg_enc}/versions/${vid}"; then
                  echo "WARN: Failed to delete version id=${vid} (continuing)"
                fi
              done
            fi

            # If nuking everything, also remove the (now empty) package
            if [ "${kept}" -eq 0 ] && [ "${age_days}" -eq 0 ]; then
              echo "All versions removed; deleting empty package ${pkg}..."
              if ! api_delete "${PKG_BASE}/${pkg_enc}"; then
                echo "WARN: Failed to delete package ${pkg} (may still have versions or be protected)"
              fi
            fi

            echo "::endgroup::"
          done < packages.txt
